#! /bin/env python3 
# analysis.py
# tranverses the directory structure created by run.py and constructs a data table
# then enables data analysis on the data such as by creating plots

import os, csv
import matplotlib.pyplot as plt
import statistics

CPUs = [
        "ThinkPadX270", "ThinkPadX61Tablet", "ThinkPadX120e",
        "Latitude7480", "LatitudeE6230", "LatitudeE6400",
        "LatitudeE6500",
        ]

#CPU = ["ThinkPadX270"] #, "ThinkPadX61Tablet"]
#CPU = ["ThinkPadX120e"]
#CPU = [CPUs[5], CPUs[6]]
CPU = [CPUs[4]]


def read_data(fname):
    run = {}
    data = csv.reader(open(fname).readlines()[2:])
    for dat in data:
        run[dat[2]] = dat
    return run

'''
    data = dictionary of test data so far
    machine = CPU to add info to data dictionary for
    test_foldr = folder name containing the tests we want data from
Navigates the folder structure and adds data the for given machine and test
    to the data dictionary
'''
def generate_data(data, machine, test_foldr):
    root = os.getcwd()
    m = machine
    
    if m not in data:
        # create a dictionary entry for this machine
        data[m] = dict()

    foldr = root + "/data/" + machine + "/" + test_foldr + "/"

    # get list of compiler folders
    compilers = list(filter(lambda p: os.path.isdir(foldr + p), os.listdir(foldr)))
    for c in compilers:
        data[m][c] = dict()
        cpath = foldr + c + "/"
        # get list of flag folders
        flags = list(filter(lambda p: os.path.isdir(cpath + p), os.listdir(cpath)))
        for f in flags:
            data[m][c][f] = dict()
            fpath = cpath + f + "/"
            
            for pf in [True, False]:
                # get all csv files with stat data
                stats = list(filter(lambda x: x[-3:] == "csv", os.listdir((fpath + str(pf)))))
                        
                data[m][c][f][pf] = [read_data(fpath + str(pf) + "/" + fname) for fname in stats]
    
    return data

'''
    data = dictionary of test data indexed as
        data[machine][compiler][flag][prefetch bool][index][desired data field]
        e.g., data["ThinkPadX270"]["gcc"]["-O0"][True][4]["branch-misses"]
    x_cat = category to plot on the x axis
    y_cat = category to plot on the y axis
        BOTH should be generated by perf and we are plotting y vs x
    machines = list of machines to plot this data for
    test_name = name of this test, only used to distinguish the plot
    pf = boolean, indicates whether we want to compare for prefetch on/off
        (only use prefetcher off if this is false)
    flags = list of flags to use for all CPUs and compilers, or None to use them all
    save = boolean, indicates whether we want to save the plot to a file
Uses the data dictionary to generate a plot of some desired data
If saving a plot, uses a standard format and saves to plot_data
'''
def generate_plots(data, x_cat, y_cat, machines, test_name, pf = True, flags = None, save = True):
    #x_cat = 'L1-dcache-loads'
    #y_cat = 'L1-dcache-load-misses'
    plt.figure(figsize=(7,7))
    # check the number of machines so we don't print the machine if only 1
    one_m = len(machines) == 1
    # to build up the legend as we go
    legend_list = []
    
    for m in machines:
        for c in data[m]:
            fs = (data[m][c] if flags == None else flags)
            for f in fs:
                pfs = (data[m][c][f] if pf else ["False"])
                for p in pfs:
                    # [:-1] --> exclude the multi from the data to plot
                    to_plot = data[m][c][f][p][:-1]
                    # get the first value in the CSV, the number for this category,
                    # for each of the x and y datapoints
                    x = list(map(lambda d: float(d[x_cat][0]), to_plot))
                    y = list(map(lambda d: float(d[y_cat][0]), to_plot))
                    plt.scatter(x, y)
                    legend = ""
                    # add the machine to the legend if there are multiple
                    legend += "" if one_m else (m + " ")
                    # add the compiler to the legend if there are multiple
                    legend += c #"" if len(data[m]) == 1 else (" " + c)
                    # add the flag for this test
                    legend += " " + f
                    # add the prefetcher if it matters
                    legend += " w/ PF on" if p == True else (" w/ PF off" if p == False and pf else "")
                    
                    legend_list.append(legend)
    # set up the final plot and show it
    plt.title(y_cat + " vs. " + x_cat + \
              ((" for " + machines[0]) if one_m else ""))
    plt.xlabel(x_cat, fontsize = 20)
    plt.ylabel(y_cat, fontsize = 20)
    plt.legend(legend_list)
    if save:
        ms = "-for-" + "-".join(machines)
        root = os.getcwd()
        plt.savefig(root + "\\plot_data\\" + test_name + "-" + y_cat + "-vs-" + x_cat + ms + ".png")
    plt.show()

'''
    data = dictionary of test data indexed as
        data[machine][compiler][flag][prefetch bool][index][desired data field]
        e.g., data["ThinkPadX270"]["gcc"]["-O0"][True][4]["branch-misses"]
    cat = category to plot for each machine; should be generated by perf
    machines = list of machines to plot this data for
    test_name = name of this test, only used to distinguish the plot
    pf = boolean, indicates whether we want to compare for prefetch on/off
        (only use prefetcher off if this is false)
    flags = list of flags to use for all CPUs and compilers, or None to use them all
    save = boolean, indicates whether we want to save the plot to a file
Uses the passed in data dictionary to generate a bar plot for the 
specified machines and categories, with sub-bars for each compiler/setting
'''
def generate_bar_plots(data, cat, machines, test_name, pf = True, flags = None, save = True):
    
    plt.figure(figsize = (10,7))
    tot_space = 10
    space_per_m = tot_space / (2*len(machines))
    locs = [2*i*space_per_m for i in range(len(machines))]
    
    # check the number of machines so we don't print the machine if only 1
    one_m = len(machines) == 1

    # legend for subplots and locations of the bars themselves
    legend_list = []
    minor = []

    for (m, loc) in zip(machines, locs):
        for_this = []
        for c in data[m]:
            fs = (data[m][c] if flags == None else flags)
            for f in fs:
                pfs = (data[m][c][f] if pf else ["False"])
                for p in pfs:
                    # [:-1] --> exclude the multi from the data to plot
                    to_plot = data[m][c][f][p][:-1]
                    # get the first value in the CSV, the number for this category,
                    # for each of the datapoints
                    y = list(map(lambda d: float(d[cat][0]), to_plot))
                    # average the result so we get ONE bar
                    y = statistics.mean(y)
                    legend = ""
                    # add the machine to the legend if there are multiple
                    legend += "" if one_m else (m + " ")
                    # add the compiler to the legend
                    legend += c #"" if len(data[m]) == 1 else (" " + c)
                    # add the flag for this test
                    legend += " " + f
                    # add the prefetcher if it matters
                    legend += " w/ PF on" if p == True else (" w/ PF off" if p == False and pf else "")
                    # add the data from this branch
                    for_this.append((legend, y))
                    legend_list.append(legend)

        # determine how much space to alloc to each sub-bar
        space_per_setting = space_per_m / len(for_this)

        for i in range(len(for_this)):
            bar_loc = loc - space_per_m / 2 + (i + 1/2) * space_per_setting
            minor.append(bar_loc)
            plt.bar([bar_loc], [for_this[i][1]], space_per_setting, label = for_this[i][0])

    plt.title("Comparison of " + cat + \
              ((" for " + machines[0]) if one_m else ""))
    if not one_m:
        plt.xlabel("Machine", fontsize = 20)
    assert(len(locs) == len(machines))
    assert(len(minor) == len(legend_list))
    print("Legend list: ", legend_list)
    minor_labels = list(map(lambda s: s.replace(" w/ ", "\n"), legend_list))
    plt.xticks(minor, minor_labels, minor = True, fontsize = 8)
    plt.xticks(locs, machines, minor = False)
    plt.ylabel(cat, fontsize = 20)
    plt.legend(legend_list)
    if save:
        ms = "-for-" + "-".join(machines)
        root = os.getcwd()
        plt.savefig(root + "\\plot_data\\" + test_name + "-" + cat + ms + ".png")

    plt.show()


def main():
    root = os.getcwd()
    #machine = input("Enter the machine to get data for: ")
    machine = CPU
    #x_cat = 'L1-dcache-loads'
    x_cat = 'cycles'
    y_cats = [
             'L1-dcache-loads', 'L1-dcache-load-misses', 
             'context-switches', 'L1-icache-load-misses',
             'page-faults', 'cpu-migrations',
             'instructions', 'branch-misses', 'branches',
             'dTLB-loads', 'dTLB-load-misses',
             'iTLB-loads', 'iTLB-load-misses',
             'LLC-loads', 'LLC-load-misses',
             ]

    #test_foldr = input("Enter the folder containing all test data: ")
    test_foldr = "Test1"

    data = dict()

    for machine in CPU:
        data = generate_data(data, machine, test_foldr)
        
    #for y_cat in y_cats:
    #    generate_plots(data, x_cat, y_cat, CPU, test_foldr)

    generate_bar_plots(data, y_cats[0], CPU, test_foldr)

if __name__ == "__main__":
    main()


