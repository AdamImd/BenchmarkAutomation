#! /bin/env python3 
# analysis.py
# tranverses the directory structure created by run.py and constructs a data table
# then enables data analysis on the data such as by creating plots

import os, csv
import matplotlib.pyplot as plt

CPUs = [
        "ThinkPadX270", "ThinkPadX61Tablet", "ThinkPadX120e",
        "Latitude7480", "LatitudeE6230", "LatitudeE6400",
        "LatitudeE6500",
        ]

#CPU = ["ThinkPadX270"] #, "ThinkPadX61Tablet"]
#CPU = ["ThinkPadX120e"]
CPU = [CPUs[3]]

def read_data(fname):
    run = {}
    data = csv.reader(open(fname).readlines()[2:])
    for dat in data:
        run[dat[2]] = dat
    return run

'''
    data = dictionary of test data so far
    machine = CPU to add info to data dictionary for
    test_foldr = folder name containing the tests we want data from
Navigates the folder structure and adds data the for given machine and test
    to the data dictionary
'''
def generate_data(data, machine, test_foldr):
    root = os.getcwd()
    m = machine
    
    if m not in data:
        # create a dictionary entry for this machine
        data[m] = dict()

    foldr = root + "/data/" + machine + "/" + test_foldr + "/"

    # get list of compiler folders
    compilers = list(filter(lambda p: os.path.isdir(foldr + p), os.listdir(foldr)))
    for c in compilers:
        data[m][c] = dict()
        cpath = foldr + c + "/"
        # get list of flag folders
        flags = list(filter(lambda p: os.path.isdir(cpath + p), os.listdir(cpath)))
        for f in flags:
            data[m][c][f] = dict()
            fpath = cpath + f + "/"
            
            for pf in [True, False]:
                # get all csv files with stat data
                stats = list(filter(lambda x: x[-3:] == "csv", os.listdir((fpath + str(pf)))))
                        
                data[m][c][f][pf] = [read_data(fpath + str(pf) + "/" + fname) for fname in stats]
    
    return data

'''
    data = dictionary of test data indexed as
        data[machine][compiler][flag][prefetch bool][index][desired data field]
        e.g., data["ThinkPadX270"]["gcc"]["-O0"][True][4]["branch-misses"]
    x_cat = category to plot on the x axis
    y_cat = category to plot on the y axis
        BOTH should be generated by perf and we are plotting y vs x
    machines = list of machines to plot this data for
    pf = boolean, indicates whether we want to compare for prefetch on/off
        (only use prefetcher off if this is false)
    save = boolean, indicates whether we want to save the plot to a file
Uses the data dictionary to generate a plot of some desired data
If saving a plot, uses a standard format and saves to plot_data
'''
def generate_plots(data, x_cat, y_cat, machines, test_name, pf = True, flags = None, save = True):
    #x_cat = 'L1-dcache-loads'
    #y_cat = 'L1-dcache-load-misses'
    plt.figure(figsize=(7,7))
    # check the number of machines so we don't print the machine if only 1
    one_m = len(machines) == 1
    # to build up the legend as we go
    legend_list = []
    
    for m in machines:
        for c in data[m]:
            fs = (data[m][c] if flags == None else flags)
            for f in fs:
                pfs = (data[m][c][f] if pf else ["False"])
                for p in pfs:
                    # [:-1] --> exclude the multi from the data to plot
                    to_plot = data[m][c][f][p][:-1]
                    # get the first value in the CSV, the number for this category,
                    # for each of the x and y datapoints
                    x = list(map(lambda d: float(d[x_cat][0]), to_plot))
                    y = list(map(lambda d: float(d[y_cat][0]), to_plot))
                    plt.scatter(x, y)
                    legend = ""
                    # add the machine to the legend if there are multiple
                    legend += "" if one_m else (m + " ")
                    # add the compiler to the legend if there are multiple
                    legend += c #"" if len(data[m]) == 1 else (" " + c)
                    # add the flag for this test
                    legend += " " + f
                    # add the prefetcher if it matters
                    legend += " w/ PF on" if p == True else (" w/ PF off" if p == False and pf else "")
                    
                    legend_list.append(legend)
    # set up the final plot and show it
    plt.title(y_cat + " vs. " + x_cat + \
              ((" for " + machines[0]) if one_m else ""))
    plt.xlabel(x_cat, fontsize = 20)
    plt.ylabel(y_cat, fontsize = 20)
    plt.legend(legend_list)
    if save:
        ms = "-for-" + "-".join(machines)
        root = os.getcwd()
        plt.savefig(root + "\\plot_data\\" + test_name + "-" + y_cat + "-vs-" + x_cat + ms + ".png")
    plt.show()

def main():
    root = os.getcwd()
    #machine = input("Enter the machine to get data for: ")
    machine = CPU
    #x_cat = 'L1-dcache-loads'
    x_cat = 'cycles'
    y_cats = [
             'L1-dcache-load-misses', 'L1-dcache-loads',
             'L1-icache-load-misses', #'L1-icache-loads', not supported!
             'LLC-loads', 'LLC-load-misses',
             ]

    test_foldr = input("Enter the folder containing all test data: ")

    data = dict()

    for machine in CPU:
        data = generate_data(data, machine, test_foldr)
        
    for y_cat in y_cats:
        generate_plots(data, x_cat, y_cat, CPU, test_foldr)

if __name__ == "__main__":
    main()
